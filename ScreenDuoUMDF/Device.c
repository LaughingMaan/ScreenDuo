/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    User-mode Driver Framework 2

--*/

#include "driver.h"
#include "device.tmh"
#include <wdfusb.h>


NTSTATUS
ScreenDuoUMDFCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "KdPrintEx %s", "ScreenDuoUMDFCreateDevice"));
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");
    WDF_OBJECT_ATTRIBUTES deviceAttributes;
    PDEVICE_CONTEXT deviceContext;
    WDFDEVICE device;
    NTSTATUS status;
	WDF_PNPPOWER_EVENT_CALLBACKS        pnpPowerCallbacks;


	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
	pnpPowerCallbacks.EvtDevicePrepareHardware = ScreenDuoUMDFEvtDevicePrepareHardware;
	pnpPowerCallbacks.EvtDeviceD0Entry = ScreenDuoUMDFEvtDeviceD0Entry;
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

    if (NT_SUCCESS(status)) {
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        deviceContext = DeviceGetContext(device);

        //
        // Initialize the context.
        //
        deviceContext->PrivateDeviceData = 0;

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        status = WdfDeviceCreateDeviceInterface(
            device,
            &GUID_DEVINTERFACE_ScreenDuoUMDF,
            NULL // ReferenceString
            );

        if (NT_SUCCESS(status)) {
            //
            // Initialize the I/O Package and any Queues
            //
            status = ScreenDuoUMDFQueueInitialize(device);
        }
    }
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");
    return status;
}

NTSTATUS
ScreenDuoUMDFEvtDevicePrepareHardware(
	IN WDFDEVICE Device,
	IN WDFCMRESLIST ResourceList,
	IN WDFCMRESLIST ResourceListTranslated
)
/*++

Routine Description:

	In this callback, the driver does whatever is necessary to make the
	hardware ready to use.  In the case of a USB device, this involves
	reading and selecting descriptors.

Arguments:

	Device - handle to a device

	ResourceList - handle to a resource-list object that identifies the
				   raw hardware resources that the PnP manager assigned
				   to the device

	ResourceListTranslated - handle to a resource-list object that
							 identifies the translated hardware resources
							 that the PnP manager assigned to the device

Return Value:

	NT status value

--*/
{
	WDFDEVICE m_Device = Device;
	NTSTATUS                            status;
	PDEVICE_CONTEXT                     pDeviceContext;
	WDF_USB_DEVICE_INFORMATION          deviceInfo;
	ULONG                               waitWakeEnable;
	WDF_USB_DEVICE_CREATE_CONFIG		Config;
	UNREFERENCED_PARAMETER(ResourceList);
	UNREFERENCED_PARAMETER(ResourceListTranslated);
	waitWakeEnable = FALSE;
	WDF_USB_DEVICE_CREATE_CONFIG_INIT(
		&Config,
		//USBD_CLIENT_CONTRACT_VERSION_602
		0x602
	);
	PAGED_CODE();
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");
	status = STATUS_SUCCESS;
	_Analysis_assume_(status == 0);
	pDeviceContext = DeviceGetContext(Device);
	//
   // Create a USB device handle so that we can communicate with the
   // underlying USB stack. The WDFUSBDEVICE handle is used to query,
   // configure, and manage all aspects of the USB device.
   // These aspects include device properties, bus properties,
   // and I/O creation and synchronization. We only create device the first
   // the PrepareHardware is called. If the device is restarted by pnp manager
   // for resource rebalance, we will use the same device handle but then select
   // the interfaces again because the USB stack could reconfigure the device on
   // restart.
   //
	if (Device == NULL) {
		TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Device == NULLLLLLLLLLLLLLLL");
	}
	if (pDeviceContext->UsbDevice == NULL) {
	//	status = WdfUsbTargetDeviceCreate(Device,
	//		WDF_NO_OBJECT_ATTRIBUTES,
	//		&pDeviceContext->UsbDevice);
		//WDFUSBDEVICE                    UsbDevice;
		//UsbDevice = NULL;
		//pDeviceContext->UsbDevice = NULL;
		status = WdfUsbTargetDeviceCreateWithParameters(m_Device, &Config, WDF_NO_OBJECT_ATTRIBUTES, &pDeviceContext->UsbDevice);
	}
	if (!NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"WdfUsbTargetDeviceCreate failed with Status code %!STATUS!\n", status);
		return status;
	}
	WDF_USB_DEVICE_INFORMATION_INIT(&deviceInfo);

	status = WdfUsbTargetDeviceRetrieveInformation(
		pDeviceContext->UsbDevice,
		&deviceInfo);

	if (NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "IsDeviceHighSpeed: %s\n",
			(deviceInfo.Traits & WDF_USB_DEVICE_TRAIT_AT_HIGH_SPEED) ? "TRUE" : "FALSE");
		TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
			"IsDeviceSelfPowered: %s\n",
			(deviceInfo.Traits & WDF_USB_DEVICE_TRAIT_SELF_POWERED) ? "TRUE" : "FALSE");

		waitWakeEnable = deviceInfo.Traits &
			WDF_USB_DEVICE_TRAIT_REMOTE_WAKE_CAPABLE;

		TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
			"IsDeviceRemoteWakeable: %s\n",
			waitWakeEnable ? "TRUE" : "FALSE");
		//
		// Save these for use later.
		//
		pDeviceContext->UsbDeviceTraits = deviceInfo.Traits;
	}
	else {
		pDeviceContext->UsbDeviceTraits = 0;
	}
	status = SelectInterfaces(Device);
	if (!NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"SelectInterfaces failed 0x%x\n", status);
		return status;
	}

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");
	return status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
SelectInterfaces(
	_In_ WDFDEVICE Device
)
/*++

Routine Description:

	This helper routine selects the configuration, interface and
	creates a context for every pipe (end point) in that interface.

Arguments:

	Device - Handle to a framework device

Return Value:

	NT status value

--*/
{
	WDF_USB_DEVICE_SELECT_CONFIG_PARAMS configParams;
	NTSTATUS                            status = STATUS_SUCCESS;
	PDEVICE_CONTEXT                     pDeviceContext;
	WDFUSBPIPE                          pipe;
	WDF_USB_PIPE_INFORMATION            pipeInfo;
	UCHAR                               index;
	UCHAR                               numberConfiguredPipes;
	WDFUSBINTERFACE                     usbInterface;

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");
	PAGED_CODE();

	pDeviceContext = DeviceGetContext(Device);
	WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_INIT_SINGLE_INTERFACE(&configParams);

	usbInterface =
		WdfUsbTargetDeviceGetInterface(pDeviceContext->UsbDevice, 0);

	if (NULL == usbInterface) {
		status = STATUS_UNSUCCESSFUL;
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"WdfUsbTargetDeviceGetInterface 0 failed %!STATUS! \n",
			status);
		return status;
	}

	configParams.Types.SingleInterface.ConfiguredUsbInterface =
		usbInterface;

	configParams.Types.SingleInterface.NumberConfiguredPipes =
		WdfUsbInterfaceGetNumConfiguredPipes(usbInterface);

	pDeviceContext->UsbInterface =
		configParams.Types.SingleInterface.ConfiguredUsbInterface;

	numberConfiguredPipes = configParams.Types.SingleInterface.NumberConfiguredPipes;
	//
   // Get pipe handles
   //
	for (index = 0; index < numberConfiguredPipes; index++) {

		WDF_USB_PIPE_INFORMATION_INIT(&pipeInfo);
		pipeInfo.MaximumPacketSize = 0x200;
		pipe = WdfUsbInterfaceGetConfiguredPipe(
			pDeviceContext->UsbInterface,
			index, //PipeIndex,
			&pipeInfo
		);
		//
		// Tell the framework that it's okay to read less than
		// MaximumPacketSize
		//
		WdfUsbTargetPipeSetNoMaximumPacketSizeCheck(pipe);

		if (WdfUsbPipeTypeInterrupt == pipeInfo.PipeType) {
			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
				"Interrupt Pipe is 0x%p\n", pipe);
			pDeviceContext->InterruptPipe = pipe;
		}

		if (WdfUsbPipeTypeBulk == pipeInfo.PipeType &&
			WdfUsbTargetPipeIsInEndpoint(pipe)) {
			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
				"BulkInput Pipe is 0x%p\n", pipe);
			pDeviceContext->BulkReadPipe = pipe;
		}

		if (WdfUsbPipeTypeBulk == pipeInfo.PipeType &&
			WdfUsbTargetPipeIsOutEndpoint(pipe)) {
			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
				"BulkOutput Pipe is 0x%p\n", pipe);
			pDeviceContext->BulkWritePipe = pipe;
		}

	}
	if (!(pDeviceContext->BulkWritePipe
		&& pDeviceContext->BulkReadPipe /* && pDeviceContext->InterruptPipe*/)) {
		status = STATUS_INVALID_DEVICE_STATE;
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"Device is not configured properly %!STATUS!\n",
			status);

		return status;
	}

	return status;

}

NTSTATUS
ScreenDuoUMDFEvtDeviceD0Entry(
	WDFDEVICE Device,
	WDF_POWER_DEVICE_STATE TargetState
)
/*++

Routine Description:

	This routine undoes anything done in EvtDeviceD0Entry.  It is called
	whenever the device leaves the D0 state, which happens when the device is
	stopped, when it is removed, and when it is powered off.

	The device is still in D0 when this callback is invoked, which means that
	the driver can still touch hardware in this routine.


	EvtDeviceD0Exit event callback must perform any operations that are
	necessary before the specified device is moved out of the D0 state.  If the
	driver needs to save hardware state before the device is powered down, then
	that should be done here.

	This function runs at PASSIVE_LEVEL, though it is generally not paged.  A
	driver can optionally make this function pageable if DO_POWER_PAGABLE is set.

	Even if DO_POWER_PAGABLE isn't set, this function still runs at
	PASSIVE_LEVEL.  In this case, though, the function absolutely must not do
	anything that will cause a page fault.

Arguments:

	Device - Handle to a framework device object.

	TargetState - Device power state which the device will be put in once this
		callback is complete.

Return Value:

	Success implies that the device can be used.  Failure will result in the
	device stack being torn down.

--*/
{
	/*PDEVICE_CONTEXT         pDeviceContext;

	PAGED_CODE();*/
	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(TargetState);
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

		//DbgDevicePowerString(TargetState));

	/*pDeviceContext = GetDeviceContext(Device);

	WdfIoTargetStop(WdfUsbTargetPipeGetIoTarget(pDeviceContext->InterruptPipe), WdfIoTargetCancelSentIo);*/

			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");

	return STATUS_SUCCESS;
}